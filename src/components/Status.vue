<!-- eslint-disable vuetify/no-deprecated-components -->
<template>
  <div>
    <v-data-table
      :headers="headers"
      :items="metrics"
      class="px-2"
    >
      <!--TODO: This is to remove the "items per page" selection. Maybe find a more elegant solution?-->
      <template #bottom />
      <template #item="{item}">
        <tr>
          <td>{{ item.raw.title }}</td>
          <td>{{ this.$filters.capitalize(item.raw.type) }}</td>
          <td>{{ item.raw.group }}.{{ item.raw.name }}</td>
          <td>{{ item.raw.value || item.raw.count }}</td>
          <td>{{ avgTime(item.raw) }}</td>
        </tr>
      </template>
    </v-data-table>

    <v-data-table
      :headers="[{sortable: false},{sortable: false},{sortable: false},{sortable: false}]"
      :items="uptime"
      class="px-2"
    >
      <!--TODO: This is to remove the "items per page" selection. Maybe find a more elegant solution?-->
      <template #bottom />
      <template #item="{item}">
        <tr>
          <td>{{ $t('LastUpdate') }}</td>
          <td>
            <date-time
              v-if="item.raw.lastTime"
              :value="item.raw.lastTime"
              format="longDate"
            />
          </td>
          <td>{{ $t('Uptime') }}</td>
          <td>{{ this.$filters.days(item.raw.uptime / 1000) }}</td>
        </tr>
      </template>
    </v-data-table>
  </div>
</template>

<script>
import DateTime from './lib/DateTime'
import moment from 'moment'
import i18n from '@/plugins/i18n'

export default {
  components: {
    DateTime
  },
  data: () => ({
    headers: [
      {title: i18n.global.t('Metric'), key: 'title', sortable: false},
      {title: i18n.global.t('Type'), key: 'type', sortable: false},
      {title: i18n.global.t('Name'), key: 'name', sortable: false},
      {title: i18n.global.t('Value'), key: 'value', sortable: false},
      {title: i18n.global.t('AvgTime'), key: 'time', sortable: false},
    ]
  }),
  computed: {
    metrics() {
      return this.$store.state.management.metrics
    },
    uptime() {
      return [{
        lastTime: moment(this.$store.state.management.time).utc().toISOString(),
        uptime: this.$store.state.management.uptime
      }]
    },
    refresh() {
      return this.$store.state.refresh
    }
  },
  watch: {
    refresh(val) {
      val || this.getStatus()
    }
  },
  created() {
    this.getStatus()
  },
  methods: {
    getStatus() {
      return this.$store.dispatch('management/getStatus')
    },
    avgTime(item) {
      if (item.type == 'timer') {
        return (item.totalTime / item.count).toFixed(2) + ' ms'
      } else {
        return 'n/a'
      }
    }
  }
}
</script>

<style></style>
